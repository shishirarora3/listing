function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from "react";
import styled, { css, withTheme } from "styled-components";
import defaultTheme from "../defaultTheme";
import media, { getBreakpointWidth } from "../utils/mediaQuery";
import { ALIGNS, POSITIONS, SIZE_OPTIONS, TOOLTIP_ARROW_SIZE, TOOLTIP_TOTAL_PADDING } from "./consts";
import { StyledText } from "../Text";
import { Item } from "../List/ListItem";
import Portal from "../Portal";
import resolveContainerPosition from "./helpers/resolveContainerPosition";
import resolveContainerAlign from "./helpers/resolveContainerAlign";
import resolveTooltipArrowAlign from "./helpers/resolveTooltipArrowAlign";
import resolveTooltipArrowPosition from "./helpers/resolveTooltipArrowPosition";
import tooltipArrowStyle from "./helpers/tooltipArrowStyle";
import tooltipSize from "./helpers/tooltipSize";
import Button from "../Button";
import { isHorizontal, isPositionBottom, isPositionLeft, isPositionRight, isPositionTop, isVertical } from "./helpers/isPosition";
import { isAlignCenter, isAlignEnd, isAlignStart } from "./helpers/isAlign";
import tooltipPadding from "./helpers/tooltipPadding";
import RandomID from "../utils/randomID";
import { QUERIES } from "../utils/mediaQuery/consts";
import Translate from "../Translate";
const StyledTooltipChildren = styled.span.withConfig({
  displayName: "Tooltip__StyledTooltipChildren",
  componentId: "sc-1l15bi-0"
})(["&:focus:active{outline:none;}", "{position:relative;display:inline-block;:after{display:block;border-bottom:1px dotted currentColor;position:relative;content:\" \";width:100%;height:0;top:-1px;}}"], StyledText);
const StyledTooltip = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltip",
  componentId: "sc-1l15bi-1"
})(["width:100%;"]);
const StyledTooltipWrapper = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltipWrapper",
  componentId: "sc-1l15bi-2"
})(["display:block;position:fixed;width:100%;box-sizing:border-box;border-top-left-radius:9px;border-top-right-radius:9px;background-color:", ";box-shadow:", ";padding:", ";visibility:", ";opacity:", ";transition:bottom ", " ease-in-out,visibility ", " linear ", ";z-index:10012;bottom:", ";left:0;right:0;img{max-width:100%;}", ";&::after{width:0;height:0;border-style:solid;content:\" \";display:none;position:absolute;", ";", ";", ";", ";"], ({
  theme
}) => theme.orbit.paletteWhite, ({
  theme
}) => theme.orbit.boxShadowElevatedLevel1, ({
  theme
}) => theme.orbit.spaceMedium, ({
  shownMobile
}) => shownMobile ? "visible" : "hidden", ({
  shownMobile
}) => shownMobile ? "1" : "0", ({
  theme
}) => theme.orbit.durationNormal, ({
  theme
}) => theme.orbit.durationFast, ({
  shownMobile,
  theme
}) => !shownMobile && theme.orbit.durationNormal, ({
  shownMobile,
  tooltipWidth
}) => shownMobile ? "0" : `-${tooltipWidth}px`, media.largeMobile(css(["width:auto;max-width:", ";border-radius:", ";padding:", ";background-color:", ";visibility:", ";opacity:", ";transition:opacity ", " ease-in-out,visibility ", " ease-in-out;top:auto;right:auto;bottom:auto;left:auto;", ";", ";"], tooltipSize, ({
  theme
}) => theme.orbit.borderRadiusNormal, tooltipPadding, ({
  theme
}) => theme.orbit.paletteBlueDark, ({
  shown
}) => shown ? "visible" : "hidden", ({
  shown
}) => shown ? "1" : "0", ({
  theme
}) => theme.orbit.durationFast, ({
  theme
}) => theme.orbit.durationFast, resolveContainerPosition, resolveContainerAlign)), tooltipArrowStyle, resolveTooltipArrowPosition, resolveTooltipArrowAlign, media.largeMobile(css(["display:block;"])));
StyledTooltipWrapper.defaultProps = {
  theme: defaultTheme
};
const StyledTooltipContent = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltipContent",
  componentId: "sc-1l15bi-3"
})(["font-family:", ";font-size:", ";font-weight:", ";line-height:", ";color:", ";margin-bottom:16px;& ", ",", "{font-size:", ";font-weight:", ";color:", ";}", ";"], ({
  theme
}) => theme.orbit.fontFamily, ({
  theme
}) => theme.orbit.fontSizeTextNormal, ({
  theme
}) => theme.orbit.fontWeightNormal, ({
  theme
}) => theme.orbit.lineHeightText, ({
  theme
}) => theme.orbit.paletteInkNormal, StyledText, Item, ({
  theme
}) => theme.orbit.fontSizeTextNormal, ({
  theme
}) => theme.orbit.fontWeightNormal, ({
  theme
}) => theme.orbit.paletteInkNormal, media.largeMobile(css(["color:", ";font-size:", ";font-weight:", ";margin-bottom:0;& ", ",", "{color:", ";font-weight:", ";font-size:", ";}"], ({
  theme
}) => theme.orbit.paletteWhite, ({
  theme
}) => theme.orbit.fontSizeTextSmall, ({
  theme
}) => theme.orbit.fontWeightMedium, StyledText, Item, ({
  theme
}) => theme.orbit.paletteWhite, ({
  theme
}) => theme.orbit.fontWeightMedium, ({
  theme
}) => theme.orbit.fontSizeTextSmall)));
StyledTooltipContent.defaultProps = {
  theme: defaultTheme
};
const StyledTooltipClose = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltipClose",
  componentId: "sc-1l15bi-4"
})(["", ""], media.largeMobile(css(["display:none;visibility:hidden;"])));
StyledTooltipClose.defaultProps = {
  theme: defaultTheme
};
const StyledTooltipOverlay = styled.div.withConfig({
  displayName: "Tooltip__StyledTooltipOverlay",
  componentId: "sc-1l15bi-5"
})(["position:fixed;display:block;visibility:", ";width:100%;height:100%;top:0;right:0;bottom:0;left:0;background-color:rgba(23,27,30,0.6);z-index:10011;opacity:", ";transition:opacity ", " ease-in-out,visibility ", " linear ", ";", ";"], ({
  shownMobile
}) => shownMobile ? "visible" : "hidden", ({
  shownMobile
}) => shownMobile ? "1" : "0", ({
  theme
}) => theme.orbit.durationNormal, ({
  theme
}) => theme.orbit.durationFast, ({
  shownMobile,
  theme
}) => !shownMobile && theme.orbit.durationNormal, media.largeMobile(css(["display:none;visibility:hidden;"])));
StyledTooltipOverlay.defaultProps = {
  theme: defaultTheme
};

class Tooltip extends React.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      position: POSITIONS.RIGHT,
      align: ALIGNS.CENTER,
      shown: false,
      shownMobile: false
    });

    _defineProperty(this, "container", React.createRef());

    _defineProperty(this, "tooltip", React.createRef());

    _defineProperty(this, "content", React.createRef());

    _defineProperty(this, "overlay", React.createRef());

    _defineProperty(this, "containerTop", 0);

    _defineProperty(this, "containerLeft", 0);

    _defineProperty(this, "containerHeight", 0);

    _defineProperty(this, "containerWidth", 0);

    _defineProperty(this, "tooltipWidth", 0);

    _defineProperty(this, "tooltipHeight", 0);

    _defineProperty(this, "windowWidth", 0);

    _defineProperty(this, "windowHeight", 0);

    _defineProperty(this, "contentHeight", 0);

    _defineProperty(this, "closeButton", React.createRef());

    _defineProperty(this, "getDimensions", () => {
      if (this.container && this.tooltip && this.content && typeof window !== "undefined") {
        const containerDimensions = this.container.current.getBoundingClientRect();
        const tooltipDimensions = this.tooltip.current.getBoundingClientRect(); // container positions and dimensions for calculation

        const containerTop = containerDimensions.top;
        const containerLeft = containerDimensions.left;
        const containerHeight = containerDimensions.height;
        const containerWidth = containerDimensions.width; // tooltip dimensions for calculation

        const tooltipHeight = tooltipDimensions.height;
        const tooltipWidth = tooltipDimensions.width; // window dimensions for calculation

        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        this.containerTop = containerTop;
        this.containerLeft = containerLeft;
        this.containerHeight = containerHeight;
        this.containerWidth = containerWidth;
        this.tooltipHeight = tooltipHeight;
        this.tooltipWidth = tooltipWidth;
        this.windowWidth = windowWidth;
        this.windowHeight = windowHeight;
        this.contentHeight = this.content.current && this.content.current.getBoundingClientRect().height;
      }
    });

    _defineProperty(this, "setPosition", desiredPositions => {
      const {
        containerTop,
        containerLeft,
        containerHeight,
        containerWidth,
        tooltipWidth,
        tooltipHeight,
        windowWidth,
        windowHeight
      } = this;
      const canBePositionLeft = containerLeft - tooltipWidth - TOOLTIP_ARROW_SIZE > 0;
      const canBePositionRight = containerLeft + containerWidth + tooltipWidth + TOOLTIP_ARROW_SIZE < windowWidth;
      const canBePositionTop = containerTop - tooltipHeight > 0;
      const canBePositionBottom = containerTop + containerHeight + tooltipHeight < windowHeight; // returns the position name if the position can be set

      const isInside = p => {
        if (isPositionTop(p) && canBePositionTop) {
          return POSITIONS.TOP;
        }

        if (isPositionRight(p) && canBePositionRight) {
          return POSITIONS.RIGHT;
        }

        if (isPositionBottom(p) && canBePositionBottom) {
          return POSITIONS.BOTTOM;
        }

        if (isPositionLeft(p) && canBePositionLeft) {
          return POSITIONS.LEFT;
        }

        return false;
      };

      const possiblePositions = desiredPositions.map(p => isInside(p)) // filter all non string values
      .filter(p => typeof p === "string"); // set the first valid position
      // ordering in POSITIONS const is important

      const position = possiblePositions[0];

      if (typeof position === "string" && this.state.position !== position) {
        this.setState({
          position
        });
        this.setAlign(position);
      }
    });

    _defineProperty(this, "setAlign", position => {
      const {
        containerLeft,
        containerTop,
        containerHeight,
        containerWidth,
        tooltipWidth,
        tooltipHeight,
        windowWidth,
        windowHeight
      } = this;
      const canBeVerticalStart = containerLeft + containerWidth / 2 - TOOLTIP_TOTAL_PADDING > 0 && containerLeft + containerWidth / 2 - TOOLTIP_TOTAL_PADDING + tooltipWidth < windowWidth;
      const canBeVerticalCenter = containerLeft + containerWidth / 2 - tooltipWidth / 2 > 0 && containerLeft + containerWidth / 2 + tooltipWidth / 2 < windowWidth;
      const canBeVerticalEnd = containerLeft + containerWidth + TOOLTIP_TOTAL_PADDING < windowWidth && containerLeft + containerWidth / 2 + TOOLTIP_TOTAL_PADDING - tooltipWidth > 0;
      const canBeHorizontalStart = containerTop + containerHeight / 2 - TOOLTIP_TOTAL_PADDING > 0 && containerTop + containerHeight / 2 + (tooltipHeight - TOOLTIP_TOTAL_PADDING) < windowHeight;
      const canBeHorizontalCenter = containerTop + containerHeight / 2 - tooltipHeight / 2 > 0 && containerTop + containerHeight / 2 + tooltipHeight / 2 < windowHeight;
      const canBeHorizontalEnd = containerTop + containerHeight + TOOLTIP_TOTAL_PADDING - tooltipHeight > 0 && containerTop + containerHeight / 2 + TOOLTIP_TOTAL_PADDING < windowHeight;

      const isInside = (p, a) => {
        if (isVertical(p)) {
          if (isAlignStart(a) && canBeVerticalStart) {
            return ALIGNS.START;
          }

          if (isAlignCenter(a) && canBeVerticalCenter) {
            return ALIGNS.CENTER;
          }

          if (isAlignEnd(a) && canBeVerticalEnd) {
            return ALIGNS.END;
          }
        } else if (isHorizontal(p)) {
          if (isAlignStart(a) && canBeHorizontalStart) {
            return ALIGNS.START;
          }

          if (isAlignCenter(a) && canBeHorizontalCenter) {
            return ALIGNS.CENTER;
          }

          if (isAlignEnd(a) && canBeHorizontalEnd) {
            return ALIGNS.END;
          }
        }

        return false;
      };

      const getAlign = (p // https://github.com/facebook/flow/issues/2221
      ) => Object.keys(ALIGNS).map(a => isInside(p, ALIGNS[a])) // filter all non string values
      .filter(a => typeof a === "string");

      const possibleAligns = getAlign(position);

      if (possibleAligns.length > 0 && typeof possibleAligns[0] === "string" && this.state.align !== possibleAligns[0]) {
        this.setState({
          align: possibleAligns[0]
        });
      }
    });

    _defineProperty(this, "handleIn", () => {
      const {
        preferredPosition
      } = this.props;
      const positions = Object.keys(POSITIONS).map(k => POSITIONS[k]);
      this.getDimensions();

      if (preferredPosition) {
        this.setPosition([preferredPosition, ...positions.filter(p => p !== preferredPosition)]);
      } else {
        this.setPosition(positions);
      } // https://github.com/facebook/flow/issues/2221


      this.setState({
        shown: true
      });
    });

    _defineProperty(this, "handleOut", () => {
      this.setState({
        shown: false
      });
    });

    _defineProperty(this, "handleOpen", () => {
      this.getDimensions();

      if (this.windowWidth <= +getBreakpointWidth(QUERIES.LARGEMOBILE, this.props.theme, true)) {
        this.setState({
          shownMobile: true
        });
      }
    });

    _defineProperty(this, "handleClose", ev => {
      var _this$overlay, _this$closeButton;

      ev.stopPropagation();

      if (ev.target === ((_this$overlay = this.overlay) === null || _this$overlay === void 0 ? void 0 : _this$overlay.current) || ev.target === ((_this$closeButton = this.closeButton) === null || _this$closeButton === void 0 ? void 0 : _this$closeButton.current)) {
        this.setState({
          shownMobile: false
        });
      }
    });

    _defineProperty(this, "tooltipId", void 0);
  }

  componentDidMount() {
    this.tooltipId = RandomID("tooltip");
  }

  componentDidUpdate(prevProps) {
    if (this.props !== prevProps) {
      this.getDimensions();
    }
  }

  render() {
    const {
      content,
      children,
      size = SIZE_OPTIONS.SMALL,
      dataTest,
      tabIndex = "0"
    } = this.props;
    const {
      shown,
      shownMobile,
      position,
      align
    } = this.state;
    const {
      containerTop,
      containerLeft,
      containerHeight,
      containerWidth,
      tooltipHeight,
      tooltipWidth,
      contentHeight
    } = this;
    return React.createElement(React.Fragment, null, React.createElement(StyledTooltipChildren, {
      onClick: this.handleOpen,
      onMouseEnter: this.handleIn,
      onMouseLeave: this.handleOut,
      onFocus: this.handleIn,
      onBlur: this.handleOut,
      ref: this.container,
      "aria-describedby": this.tooltipId,
      tabIndex: tabIndex
    }, children), React.createElement(Portal, {
      element: "tooltips"
    }, React.createElement(StyledTooltip, {
      "data-test": dataTest
    }, React.createElement(StyledTooltipOverlay, {
      onClick: this.handleClose,
      onFocus: this.handleOpen,
      shownMobile: shownMobile,
      ref: this.overlay
    }), React.createElement(StyledTooltipWrapper, {
      shown: shown,
      shownMobile: shownMobile,
      position: position,
      align: align,
      size: size,
      ref: this.tooltip,
      onMouseEnter: this.handleIn,
      onClick: this.handleClose,
      onMouseLeave: this.handleOut,
      containerTop: containerTop,
      containerLeft: containerLeft,
      containerHeight: containerHeight,
      containerWidth: containerWidth,
      tooltipHeight: tooltipHeight,
      tooltipWidth: tooltipWidth,
      contentHeight: contentHeight,
      role: "tooltip",
      "aria-hidden": !shown,
      id: this.tooltipId
    }, React.createElement(StyledTooltipContent, {
      ref: this.content
    }, content), React.createElement(StyledTooltipClose, null, React.createElement(Button, {
      type: "secondary",
      block: true,
      onClick: this.handleClose,
      ref: this.closeButton
    }, React.createElement(Translate, {
      tKey: "button_close"
    })))))));
  }

}

_defineProperty(Tooltip, "defaultProps", {
  theme: defaultTheme
});

const ThemedTooltip = withTheme(Tooltip);
ThemedTooltip.displayName = "Tooltip";
export default ThemedTooltip;